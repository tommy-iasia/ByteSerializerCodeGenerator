package com.iasia.code;

import com.iasia.buffer.ByteSerializable;
import org.yaml.snakeyaml.Yaml;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class DataClass {

    private DataClass(String className, String filePath, List<DataProperty> properties) {
        this.className = className;
        this.filePath = filePath;
        this.properties = properties;
    }

    public final String filePath;
    private String getFileName() {
        var pattern = Pattern.compile("[^\\\\.]+\\.yaml$");
        var matcher = pattern.matcher(filePath);
        if (!matcher.find()) {
            throw new RuntimeException();
        }

        return matcher.group(0);
    }
    private String getOutputPath() {
        return filePath.replaceAll("\\.yaml$", ".java");
    }
    private String getPackage() {
        return filePath
                .replace('\\', '.')
                .replaceAll("\\.[^.]+\\.yaml$", "")
                .replaceAll("(^.+\\.)?src\\.(main\\.)?(java\\.)?", "");
    }

    public final String className;
    public final List<DataProperty> properties;

    @SuppressWarnings("unchecked")
    private static DataClass read(String filePath) throws IOException {
        try (var fileReader = new FileReader(filePath)) {
            Yaml yaml = new Yaml();
            Map<String, Object> fileMap = yaml.load(fileReader);
            var fileEntry = fileMap.entrySet().iterator().next();

            var className = fileEntry.getKey();

            var propertiesList = new ArrayList<DataProperty>();
            var dataClass = new DataClass(className, filePath, propertiesList);

            var propertiesArray = (ArrayList<Object>) fileEntry.getValue();
            for (var propertyValue : propertiesArray) {
                var property = DataProperty.parse(propertyValue, dataClass);
                propertiesList.add(property);
            }

            return dataClass;
        }
    }

    public static void write(String filePath) throws IOException {
        var dataClass = read(filePath);

        var outputPath = dataClass.getOutputPath();
        try (var fileWriter = new FileWriter(outputPath);
             var printWriter = new PrintWriter(fileWriter)) {
            printWriter.println("package " + dataClass.getPackage() + ";");

            var imports = dataClass.imports();
            if (!imports.isEmpty()) {
                printWriter.println();

                for (var importClass : imports) {
                    printWriter.println("import " + importClass + ";");
                }
            }

            printWriter.println();
            printWriter.println("//don't edit this file as it is auto-generated by ByteSerializerCodeGenerator");
            printWriter.println("//instead, edit the source file " + dataClass.getFileName());
            printWriter.println("//https://github.com/tommy-iasia/ByteSerializerCodeGenerator");
            printWriter.println();

            var body = dataClass.body();
            for (var line : body) {
                printWriter.println(line);
            }
        }
    }

    private List<String> imports() {
        var imports = new LinkedList<String>();

        imports.add("java.nio.ByteBuffer");
        imports.add("java.nio.ByteOrder");

        imports.add(ByteSerializable.class.getCanonicalName());

        var propertyImports = properties.stream().flatMap(t -> t.imports().stream()).collect(Collectors.toSet());
        imports.addAll(propertyImports);

        Collections.sort(imports);

        return imports;
    }

    private List<String> body() {
        var lines = new LinkedList<String>();

        lines.add("public class " + className + " implements " + ByteSerializable.class.getSimpleName() + " {");
        lines.add("");

        lines.add("    public final static String CLASS_NAME = \"" + className + "\";");
        lines.add("");

        var constructor = constructor();
        addLines(lines, constructor);

        var fields = fields();
        if (!fields.isEmpty()) {
            lines.add("");
            addLines(lines, fields);
        }

        var getters = getters();
        if (!getters.isEmpty()) {
            addParts(lines, getters);
        }

        var setters = setters();
        if (!setters.isEmpty()) {
            addParts(lines, setters);
        }

        lines.add("");

        var read = read();
        addLines(lines, read);

        lines.add("");

        var write = write();
        addLines(lines, write);

        var length = length();
        addLines(lines, length);

        var fill = fill();
        addLines(lines, fill);

        lines.add("");

        var debug = debug();
        addLines(lines, debug);

        lines.add("}");

        return lines;
    }
    private static void addParts(List<String> lines, List<List<String>> parts) {
        for (var part : parts) {
            if (part.isEmpty()) {
                continue;
            }

            lines.add("");

            for (var line : part) {
                lines.add("    " + line);
            }
        }
    }
    private static void addLines(List<String> lines, List<String> adds) {
        for (var line : adds) {
            lines.add("    " + line);
        }
    }

    private List<String> constructor() {
        var lines = new LinkedList<String>();

        var fullProperties = properties.stream()
                .filter(t -> t.name != null)
                .collect(Collectors.toList());

        var requiredProperties = fullProperties.stream()
                .filter(DataProperty::constructorRequired)
                .collect(Collectors.toList());

        if (requiredProperties.size() < fullProperties.size()) {
            var requiredConstructor = constructor(requiredProperties);
            lines.addAll(requiredConstructor);
        }

        var fullConstructor = constructor(fullProperties);
        lines.addAll(fullConstructor);

        return lines;
    }
    private List<String> constructor(List<DataProperty> properties) {
        if (properties.isEmpty()) {
            return Collections.singletonList("public " + className + "() { }");
        } else {
            var lines = new LinkedList<String>();

            var parameters = properties.stream()
                    .map(DataProperty::constructorParameter)
                    .collect(Collectors.toList());

            lines.add("public " + className + "(" + String.join(", ", parameters) + ") {");

            for (var property : properties) {
                var set = property.innerSet();
                if (set != null) {
                    lines.add("    " + set);
                }
            }

            lines.add("}");

            return lines;
        }
    }

    private List<String> fields() {
        return properties.stream()
                .map(DataProperty::field)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    private List<List<String>> getters() {
        return properties.stream()
                .map(DataProperty::getter)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }
    private List<List<String>> setters() {
        return properties.stream()
                .map(DataProperty::setter)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }

    private List<String> read() {
        var outputLines = new LinkedList<String>();

        var readProperties = new LinkedList<DataProperty>();
        var readLines = new LinkedList<String>();

        for (var property : properties) {
            var read = property.read();
            if (!read.isEmpty()) {
                readProperties.add(property);
                readLines.addAll(read);
            }
        }

        var inputProperties = properties.stream().filter(t -> t.name != null).collect(Collectors.toList());
        inputProperties.removeAll(readProperties);
        inputProperties.removeIf(t -> !t.constructorRequired());

        if (inputProperties.isEmpty()) {
            outputLines.add("public static " + className + " get(ByteBuffer buffer) {");
        } else {
            var inputParameters = inputProperties.stream()
                    .map(DataProperty::constructorParameter)
                    .collect(Collectors.toList());

            outputLines.add("public static " + className + " get("
                    + String.join(", ", inputParameters) + ", "
                    + "ByteBuffer buffer) {");
        }

        if (!readLines.isEmpty()) {
            addLines(outputLines, readLines);
            outputLines.add("");
        }

        var valuePropertiesSet = new HashSet<DataProperty>();
        valuePropertiesSet.addAll(readProperties);
        valuePropertiesSet.addAll(inputProperties);

        var orderedValueProperties = new LinkedList<>(properties);
        orderedValueProperties.retainAll(valuePropertiesSet);

        var valueNames = orderedValueProperties.stream()
                .map(t -> t.name)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        outputLines.add("    return new " + className + "(" + String.join(", ", valueNames) + ");");

        outputLines.add("}");

        return outputLines;
    }

    private List<String> write() {
        return Arrays.asList(
                "@Override",
                "public ByteBuffer put() {",
                "    var length = length();",
                "    var buffer = ByteBuffer.allocate(length).order(ByteOrder.LITTLE_ENDIAN);",
                "",
                "    put(buffer);",
                "",
                "    buffer.flip();",
                "    return buffer;",
                "}");
    }
    private List<String> length() {
        var lines = new LinkedList<String>();

        lines.add("@Override");
        lines.add("public int length() {");

        var lengths = properties.stream()
                .map(DataProperty::length)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());

        if (lengths.isEmpty()) {
            lines.add("    return 0;");
        } else {
            lines.add("    return " + String.join(" + ", lengths) + ";");
        }

        lines.add("}");

        return lines;
    }
    private List<String> fill() {
        var lines = new LinkedList<String>();

        lines.add("@Override");
        lines.add("public void put(ByteBuffer buffer) {");

        for (var property : properties) {
            var fill = property.fill();
            addLines(lines, fill);
        }

        lines.add("}");

        return lines;
    }

    private List<String> debug() {
        var lines = new LinkedList<String>();

        lines.add("@Override");
        lines.add("public String toString() {");
        lines.add("    return \"" + className + "{\"");

        for (var property : properties) {
            var debug = property.debug();
            if (debug != null) {
                lines.add("            + " + debug);
            }
        }

        lines.add("            + \"}\";");
        lines.add("}");

        return lines;
    }
}
